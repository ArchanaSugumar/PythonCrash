# -*- coding: utf-8 -*-
"""Python_Crash_Course_1_Assignment_Solution.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tXlnkxW8v8aWag0YycYKbMvPQkW-TCPo

# **Python Basics**

## Find Compound Interest
"""

def compound_interest(principal, rate, time):
    """
    Args:
     principal(float)
     rate(float)
     time(int32)
    Returns:
     float
    """

    # Calculate the amount
    amount = principal * (1 + rate/100) ** time

    # Calculate compound interest
    compound_interest = amount - principal

    return round(compound_interest, 2)

"""## Find Factorial Of A Number"""

def calculate_factorial(n):
    """
    Args:
     n(int32): Non-negative integer for which factorial is to be calculated.
    Returns:
     int32: Factorial of the given non-negative integer.
    """

    # Initialize factorial to 1
    factorial = 1

    # Calculate factorial iteratively
    for i in range(1, n + 1):
        factorial *= i

    return factorial

"""## Reverse A Number"""

# Solution 1: Using String Manipulation

def reverse_number(n):
    """
    Args:
     n(int32): Number to be reversed.
    Returns:
     int32: Number in reverse order.
    """

    # Convert the number to string, handle the sign separately,
    # reverse it, and convert back to integer

    sign = -1 if n < 0 else 1

    reversed_str = str(abs(n))[::-1]

    reversed_num = int(reversed_str) * sign

    return reversed_num

# Solution 2: Using Mathematics

def reverse_number(n):
    """
    Args:
     n(int32): Number to be reversed.
    Returns:
     int32: Number in reverse order.
    """

    # Handle the sign separately
    sign = -1 if n < 0 else 1

    # Initialize reversed number to 0
    reversed_num = 0

    # Iterate through each digit of the absolute value of n
    n = abs(n)

    while n > 0:

        # Extract the last digit of n
        digit = n % 10

        # Append the digit to the reversed number
        reversed_num = reversed_num * 10 + digit

        # Remove the last digit from n
        n //= 10

    return reversed_num * sign

# Solution 3: Reversed list

def reverse_number(n):
    """
    Args:
     n(int32): Number to be reversed.
    Returns:
     int32: Number in reverse order.
    """

    sign = -1 if n < 0 else 1

    n= abs(n)

    str_number = str(n)

    length_str = len(str_number)

    reverse_string = ''

    for i in reversed(range(length_str)):
       reverse_string += str_number[i]

    return int(reverse_string) * sign

"""## Number Of Senior Citizens"""

# Solution 1: Using a For Loop and String Slicing

def count_senior_citizens(p):
    """
    Args:
     p(list_str): List of strings containing passenger information.
    Returns:
     int32: Number of passengers who are strictly more than 60 years old.
    """
    # Initialize count for senior citizens
    senior_count = 0

    # Iterate over each passenger information
    for passenger in p:
        # Extract age from the passenger information
        age_str = passenger[11:13]  # Extract age from 12th and 13th characters
        age = int(age_str)

        # Check if age is strictly more than 60
        if age > 60:
            senior_count += 1

    return senior_count

# Solution 2: Solution 2: Using List Comprehension and String Slicing

def count_senior_citizens(p):
    """
    Args:
     p(list_str): List of strings containing passenger information.
    Returns:
     int32: Number of passengers who are strictly more than 60 years old.
    """
    # Use list comprehension to extract ages and count senior citizens
    senior_count = sum(int(passenger[11:13]) > 60 for passenger in p)

    return senior_count

"""## Divisible By K"""

# Solution 1: Using List Comprehension
def divisible_by_k(t, k):
    """
    Args:
     t(list_list_int32): List of lists containing integers.
     k(int32): Positive integer.
    Returns:
     list_list_int32: New list of lists containing only those sublists where every element is divisible by k.
    """
    # Use list comprehension to filter sublists where all elements are divisible by k
    result = [sublist for sublist in t if all(x % k == 0 for x in sublist)]
    return result

# Solution 2: Using Nested For Loops

def divisible_by_k(t, k):
    """
    Args:
     t(list_list_int32): List of lists containing integers.
     k(int32): Positive integer.
    Returns:
     list_list_int32: New list of lists containing only those sublists where every element is divisible by k.
    """
    # Initialize an empty list to store the result
    result = []

    # Iterate through each sublist in the input list
    for sublist in t:
        # Check if every element in the sublist is divisible by k
        if all(x % k == 0 for x in sublist):
            # If all elements are divisible by k, append the sublist to the result
            result.append(sublist)

    return result

"""# **NumPy**

## Numpy-FF1
"""

# Create a 5x5 matrix filled with random integers between 1 and 100
# A = np.random.randint(1, 101, size=(5, 5))
A = arr = np.random.randint(1, 101, 25).reshape(5,5)

print(A)

# Calculate the mean and standard deviation of the matrix and print them.
mean = np.mean(A)
std = np.std(A)

print(mean)
#print(std)

"""## Numpy-FF2"""

# Create a 5x5 identity matrix and add a scalar value of 5 to it
I = np.eye(5)
aug_I = I + 0
aug_I

# Multiply the resulting matrix with a 5x1 column vector filled with random integers between 1 and 10
rand_vec = np.array([5, 5, 6, 7, 8])

result_multiply = np.multiply(aug_I, rand_vec) # *
result_star = aug_I * rand_vec
resukt_dot = np.matmul(aug_I, rand_vec)
# result = arr * rand_vec

print(result_multiply)

import numpy as np

identity_matrix = np.identity(5)
identity_matrix_plus_scalar = identity_matrix + 5
column_vector = np.random.randint(1, 11, (5, 1))

resulting_vector = np.matmul(identity_matrix_plus_scalar, column_vector)

print("Resulting Vector:\n", resulting_vector)

a = np.array([[1, 0], [0, 1]])
b = np.array([[4, 1], [2, 2]])

a

b

np.matmul(a, b)
# For element (0,0) 0th row of a [1, 0], 0th column of b , then adding

a*b # same as np.multiply

np.multiply(a, b)

"""## Numpy-FF3"""

# Create two 3x3 matrices filled with random integers between 1 and 100
A = np.random.randint(1, 101, size=(3, 3))
B = np.random.randint(1, 101, size=(3, 3))

print(A)
print()
print(B)

# Compute their element-wise multiplication, and print the resulting matrix
result = np.multiply(A, B)

print(result)

"""## Numpy-FF4"""

# Create a 1000-element array of random integers between 1 and 1000
arr = np.random.randint(1, 1001, 1000)

print(arr)

# Calculate the cumulative sum of the array
cum_arr = np.cumsum(arr)

print(cum_arr)

# Print the 10th, 100th, and 500th elements of the cumulative sum array
print(cum_arr[9])
print(cum_arr[99])
print(cum_arr[499])

# 5 days
rev = [[ 30, 60, 100, ]]
np.take_along_axis

"""# **Pandas**

## Pandas-FF1
"""

# Calculate the average rating of movies directed by Christopher Nolan
data = {
    'Title': ['Inception', 'Dunkirk', 'Interstellar', 'The Prestige', 'Memento'],
    'Director': ['Other Director', 'Christopher Nolan', 'Other Director', 'Christopher Nolan', 'Christopher Nolan'],
    'Rating': [8.8, 7.9, 8.6, 8.5, 8.4]
}

df = pd.DataFrame(data)

# df[df['Director'] == 'Christopher Nolan']
df

res = df.loc[df['Director'] == 'Christopher Nolan']

print(res['Rating'].mean())

df.query('Director == "Christopher Nolan"')["Rating"].mean()

df[df['Director'] == 'Christopher Nolan']['Rating'].mean()

df.groupby('Director')['Rating'].mean()

"""## Pandas-FF2"""

# Commented out IPython magic to ensure Python compatibility.
# Extract all rows where the price is greater than or equal to 20,000
data = {
    'Product': ['Laptop', 'Desktop', 'Tablet', 'Phone', 'Smartwatch'],
    'Price': [25000, 12000, 8000, 22000, 5000]
}

df = pd.DataFrame(data)

# Sort them in descending order by price

#
# %timeit df.where(df['Price'] >= 20000).dropna().sort_values(by='Price', ascending=False)
# %timeit df.loc[df['Price'] >= 20000].sort_values(by='Price', ascending=False)
# %timeit df.query('Price >= 20000').sort_values(by='Price', ascending=False)
# %timeit df[df['Price'] >= 20000].sort_values(by='Price', ascending=False)

"""## Pandas-FF3"""

# Find the total revenue and average price of items sold in each store
data = {
    'Store': ['A', 'B', 'A', 'B', 'A', 'B', 'A', 'B'],
    'Item': ['Apple', 'Banana', 'Orange', 'Grape', 'Apple', 'Banana', 'Orange', 'Grape'],
    'Price': [50, 20, 30, 60, 55, 22, 33, 65],
    'Quantity': [10, 12, 15, 16, 20, 25, 30, 35]
}

df = pd.DataFrame(data)

df['Revenue'] = df['Price'] * df['Quantity']

store_nums = df.groupby('Store').agg({'Revenue': 'sum', 'Price': 'mean'}).reset_index()

store_nums.rename(columns={'Price': 'Average_Price', 'Revenue': 'Total_Revenue'}, inplace=True)

store_nums

"""## Pandas-FF4"""

filter = df.groupby("Store")

total_revenue = filter.apply(lambda x: (x['Price'] * x['Quantity']).sum()).rename('total revenue').reset_index()
average_price = filter['Price'].mean().rename('average price').reset_index()

df = pd.merge(total_revenue, average_price, on = 'Store')
df

# Commented out IPython magic to ensure Python compatibility.
# Calculate the total amount spent by each customer
data = {
    'Customer': ['Alice', 'Bob', 'Alice', 'Alice', 'Bob', 'Bob', 'Alice', 'Bob'],
    'Item': ['Pen', 'Pencil', 'Notebook', 'Eraser', 'Pen', 'Pencil', 'Notebook', 'Eraser'],
    'Price': [10, 5, 50, 20, 10, 5, 50, 20],
    'Quantity': [3, 4, 2, 5, 10, 6, 1, 2]
}

df = pd.DataFrame(data)

df['Total_Spent'] = df['Price'] * df['Quantity']

# %timeit df.groupby('Customer')['Total_Spent'].sum().reset_index()
# %timeit df.groupby('Customer').agg({'Total_Spent': 'sum'}).reset_index()

